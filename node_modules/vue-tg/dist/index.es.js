import { defineComponent as B, onMounted as b, openBlock as A, createElementBlock as v, watch as g, onUnmounted as W, ref as s, readonly as f, computed as p } from "vue";
const se = /* @__PURE__ */ B({
  __name: "Alert",
  props: {
    message: {
      type: String,
      required: !0
    }
  },
  emits: ["close"],
  setup(e, { emit: n }) {
    const t = e, { showAlert: o } = h();
    return b(
      () => o(
        t.message,
        () => n("close")
      )
    ), (a, i) => (A(), v("div"));
  }
}), ie = /* @__PURE__ */ B({
  __name: "BackButton",
  props: {
    visible: { type: Boolean, default: !0 }
  },
  emits: ["click"],
  setup(e, { emit: n }) {
    const t = e, { showBackButton: o, onBackButtonClicked: a, hideBackButton: i } = ve();
    return g(() => t.visible, (c) => {
      c ? o() : i();
    }), a(() => n("click")), b(
      () => t.visible && o()
    ), W(
      () => i()
    ), (c, d) => (A(), v("div"));
  }
}), re = /* @__PURE__ */ B({
  __name: "Confirm",
  props: {
    message: { type: String, required: !0 }
  },
  emits: ["close"],
  setup(e, { emit: n }) {
    const t = e, { showConfirm: o } = h();
    return b(
      () => o(
        t.message,
        (a) => n("close", a)
      )
    ), (a, i) => (A(), v("div"));
  }
}), ce = /* @__PURE__ */ B({
  __name: "MainButton",
  props: {
    text: { type: String },
    color: { type: String },
    textColor: { type: String },
    visible: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    progress: { type: Boolean, default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: n }) {
    const t = e, {
      setMainButtonParams: o,
      onMainButtonClicked: a,
      hideMainButton: i,
      showMainButtonProgress: c,
      hideMainButtonProgress: d
    } = Pe();
    return g(() => t.text, (r) => {
      o({
        text: r
      });
    }), g(() => t.color, (r) => {
      o({
        color: r
      });
    }), g(() => t.textColor, (r) => {
      o({
        text_color: r
      });
    }), g(() => t.visible, (r) => {
      o({
        is_visible: r
      });
    }), g(() => t.disabled, (r) => {
      o({
        is_active: !r
      });
    }), g(() => t.progress, (r) => {
      r ? c() : d();
    }), a(() => n("click")), b(() => {
      t.progress ? c() : d(), o({
        text: t.text,
        text_color: t.textColor,
        color: t.color,
        is_active: !t.disabled,
        is_visible: t.visible
      });
    }), W(() => {
      d(), i();
    }), (r, l) => (A(), v("div"));
  }
}), ue = /* @__PURE__ */ B({
  __name: "Popup",
  props: {
    title: { type: String },
    message: { type: String, required: !0 },
    buttons: { type: Array }
  },
  emits: ["close"],
  setup(e, { emit: n }) {
    const t = e, { showPopup: o } = h();
    return b(
      () => o(
        {
          title: t.title,
          message: t.message,
          buttons: t.buttons
        },
        (a) => n("close", a)
      )
    ), (a, i) => (A(), v("div"));
  }
}), {
  initData: pe,
  initDataUnsafe: le,
  version: me,
  platform: ge,
  isVersionAtLeast: be,
  sendData: de,
  close: fe
} = Telegram.WebApp, H = s(!1), Be = (...e) => {
  Telegram.WebApp.ready(...e), H.value = !0;
}, Q = (e) => Telegram.WebApp.platform === e, V = Q("unknown"), Ae = !V && Telegram.WebApp.initData === "";
function u() {
  return {
    initData: pe,
    initDataUnsafe: le,
    version: me,
    platform: ge,
    isVersionAtLeast: be,
    onEvent: (...n) => {
      b(() => Telegram.WebApp.onEvent(...n)), W(() => Telegram.WebApp.offEvent(...n));
    },
    sendData: de,
    ready: Be,
    close: fe,
    isReady: f(H),
    isPlatform: Q,
    isPlatformUnknown: V,
    canSendData: Ae
  };
}
const U = s(Telegram.WebApp.BackButton.isVisible);
function O() {
  U.value = Telegram.WebApp.BackButton.isVisible;
}
function S(...e) {
  Telegram.WebApp.BackButton.show(...e), O();
}
function x(...e) {
  Telegram.WebApp.BackButton.hide(...e), O();
}
function ve() {
  const { onEvent: e } = u(), n = (t) => e("backButtonClicked", t);
  return {
    isBackButtonVisible: p({
      get() {
        return U.value;
      },
      set(t) {
        t ? S() : x();
      }
    }),
    onBackButtonClicked: n,
    showBackButton: S,
    hideBackButton: x
  };
}
const {
  readTextFromClipboard: Te
} = Telegram.WebApp;
function Ge() {
  const { onEvent: e } = u();
  return {
    readTextFromClipboard: Te,
    onClipboardTextReceived: (t) => e("clipboardTextReceived", t)
  };
}
const L = s(Telegram.WebApp.isClosingConfirmationEnabled);
function F() {
  L.value = Telegram.WebApp.isClosingConfirmationEnabled;
}
function M(...e) {
  Telegram.WebApp.enableClosingConfirmation(...e), F();
}
function _(...e) {
  Telegram.WebApp.disableClosingConfirmation(...e), F();
}
function Xe() {
  return {
    isClosingConfirmationEnabled: p({
      get() {
        return L.value;
      },
      set(e) {
        e ? M() : _();
      }
    }),
    enableClosingConfirmation: M,
    disableClosingConfirmation: _
  };
}
const T = Telegram.WebApp.CloudStorage;
function We(e, n) {
  return new Promise((t, o) => {
    T.setItem(e, n, (a, i) => {
      a && o(a), t(i);
    });
  });
}
function Ce(e) {
  return new Promise((n, t) => {
    T.getItem(e, (o, a) => {
      o && t(o), n(a);
    });
  });
}
function he(e) {
  return new Promise((n, t) => {
    T.getItems(e, (o, a) => {
      o && t(o), n(a);
    });
  });
}
function ke(e) {
  return new Promise((n, t) => {
    T.removeItem(e, (o, a) => {
      o && t(o), n(a);
    });
  });
}
function Se(e) {
  return new Promise((n, t) => {
    T.removeItems(e, (o, a) => {
      o && t(o), n(a);
    });
  });
}
function xe() {
  return new Promise((e, n) => {
    T.getKeys((t, o) => {
      t && n(t), e(o);
    });
  });
}
function Ye() {
  return {
    setStorageItem: We,
    getStorageItem: Ce,
    getStorageItems: he,
    removeStorageItem: ke,
    removeStorageItems: Se,
    getStorageKeys: xe
  };
}
const {
  impactOccurred: Me,
  notificationOccurred: _e,
  selectionChanged: we
} = Telegram.WebApp.HapticFeedback;
function Ze() {
  return {
    impactOccurred: Me,
    notificationOccurred: _e,
    selectionChanged: we
  };
}
const N = s(Telegram.WebApp.MainButton.text), z = s(Telegram.WebApp.MainButton.color), J = s(Telegram.WebApp.MainButton.textColor), K = s(Telegram.WebApp.MainButton.isVisible), j = s(Telegram.WebApp.MainButton.isActive), G = s(Telegram.WebApp.MainButton.isProgressVisible);
function m() {
  N.value = Telegram.WebApp.MainButton.text, z.value = Telegram.WebApp.MainButton.color, J.value = Telegram.WebApp.MainButton.textColor, K.value = Telegram.WebApp.MainButton.isVisible, j.value = Telegram.WebApp.MainButton.isActive, G.value = Telegram.WebApp.MainButton.isProgressVisible;
}
function w(...e) {
  Telegram.WebApp.MainButton.setText(...e), m();
}
function P(...e) {
  Telegram.WebApp.MainButton.show(...e), m();
}
function y(...e) {
  Telegram.WebApp.MainButton.hide(...e), m();
}
function E(...e) {
  Telegram.WebApp.MainButton.enable(...e), m();
}
function D(...e) {
  Telegram.WebApp.MainButton.disable(...e), m();
}
function R(...e) {
  Telegram.WebApp.MainButton.showProgress(...e), m();
}
function I(...e) {
  Telegram.WebApp.MainButton.hideProgress(...e), m();
}
function C(...e) {
  Telegram.WebApp.MainButton.setParams(...e), m();
}
function Pe() {
  const { onEvent: e } = u(), n = (t) => e("mainButtonClicked", t);
  return {
    mainButtonText: p({
      get() {
        return N.value;
      },
      set(t) {
        w(t);
      }
    }),
    mainButtonColor: p({
      get() {
        return z.value;
      },
      set(t) {
        C({
          color: t
        });
      }
    }),
    mainButtonTextColor: p({
      get() {
        return J.value;
      },
      set(t) {
        C({
          text_color: t
        });
      }
    }),
    isMainButtonVisible: p({
      get() {
        return K.value;
      },
      set(t) {
        t ? P() : y();
      }
    }),
    isMainButtonActive: p({
      get() {
        return j.value;
      },
      set(t) {
        t ? E() : D();
      }
    }),
    isMainButtonProgressVisible: p({
      get() {
        return G.value;
      },
      set(t) {
        t ? R() : I();
      }
    }),
    setMainButtonText: w,
    onMainButtonClicked: n,
    showMainButton: P,
    hideMainButton: y,
    enableMainButton: E,
    disableMainButton: D,
    showMainButtonProgress: R,
    hideMainButtonProgress: I,
    setMainButtonParams: C
  };
}
const {
  switchInlineQuery: ye,
  openLink: Ee,
  openTelegramLink: De,
  openInvoice: Re
} = Telegram.WebApp;
function et() {
  const { onEvent: e } = u();
  return {
    switchInlineQuery: ye,
    openLink: Ee,
    openTelegramLink: De,
    openInvoice: Re,
    onInvoiceClosed: (t) => e("invoiceClosed", t)
  };
}
const {
  showPopup: Ie,
  showAlert: $e,
  showConfirm: qe
} = Telegram.WebApp;
function h() {
  const { onEvent: e } = u();
  return {
    showPopup: Ie,
    showAlert: $e,
    showConfirm: qe,
    onPopupClosed: (t) => e("popupClosed", t)
  };
}
const {
  showScanQrPopup: He,
  closeScanQrPopup: Qe
} = Telegram.WebApp;
function Ve() {
  const { onEvent: e } = u();
  return {
    showScanQrPopup: He,
    closeScanQrPopup: Qe,
    onQrTextReceived: (t) => e("qrTextReceived", t)
  };
}
const {
  requestContact: Ue,
  requestWriteAccess: Oe
} = Telegram.WebApp;
function tt() {
  const { onEvent: e } = u();
  return {
    requestContact: Ue,
    onContactRequested: (o) => e("contactRequested", o),
    requestWriteAccess: Oe,
    onWriteAccessRequested: (o) => e("writeAccessRequested", o)
  };
}
const {
  initData: Le,
  initDataUnsafe: Fe,
  sendData: Ne,
  close: ze
} = u();
function nt(e, n) {
  const t = n.serialize ?? JSON.stringify, o = s(""), a = (c) => {
    o.value = c, console.error(c);
  }, i = s(!1);
  return {
    error: o,
    isLoading: i,
    execute: () => {
      Ne(t(e)), setTimeout(() => a("Telegram.WebApp.sendData is only available for custom keyboards."), 1e3);
    },
    executeHttp: async (c, d = {}) => {
      const r = d.closeAfter ?? !0;
      i.value = !0;
      try {
        const l = await fetch(c, {
          method: "POST",
          body: JSON.stringify({
            initData: Le,
            initDataUnsafe: Fe,
            data: t(e)
          })
        });
        return l.ok || a(`${l.status} ${l.statusText}`), l.ok && r && ze(), l;
      } catch (l) {
        a(String(l));
      } finally {
        i.value = !1;
      }
    }
  };
}
function ot() {
  const { onEvent: e } = u();
  return {
    onSettingsButtonClicked: (t) => e("settingsButtonClicked", t)
  };
}
const X = s(Telegram.WebApp.colorScheme), Y = s(Telegram.WebApp.themeParams), Z = s(Telegram.WebApp.headerColor), ee = s(Telegram.WebApp.backgroundColor);
function k() {
  X.value = Telegram.WebApp.colorScheme, Y.value = Telegram.WebApp.themeParams, Z.value = Telegram.WebApp.headerColor, ee.value = Telegram.WebApp.backgroundColor;
}
function $(...e) {
  Telegram.WebApp.setHeaderColor(...e), k();
}
function q(...e) {
  Telegram.WebApp.setBackgroundColor(...e), k();
}
function at() {
  const { onEvent: e } = u(), n = (t) => e("themeChanged", t);
  return n(k), {
    colorScheme: f(X),
    themeParams: f(Y),
    headerColor: p({
      get() {
        return Z.value;
      },
      set(t) {
        $(t);
      }
    }),
    backgroundColor: p({
      get() {
        return ee.value;
      },
      set(t) {
        q(t);
      }
    }),
    setHeaderColor: $,
    setBackgroundColor: q,
    onThemeChanged: n
  };
}
const te = s(Telegram.WebApp.isExpanded), ne = s(Telegram.WebApp.viewportHeight), oe = s(Telegram.WebApp.viewportStableHeight);
function ae() {
  te.value = Telegram.WebApp.isExpanded, ne.value = Telegram.WebApp.viewportHeight, oe.value = Telegram.WebApp.viewportStableHeight;
}
function Je(...e) {
  Telegram.WebApp.expand(...e), ae();
}
function st() {
  const { onEvent: e } = u(), n = (t) => e("viewportChanged", t);
  return n(ae), {
    isExpanded: f(te),
    viewportHeight: f(ne),
    viewportStableHeight: f(oe),
    expand: Je,
    onViewportChanged: n
  };
}
const Ke = /* @__PURE__ */ B({
  __name: "ScanQr",
  props: {
    text: { type: String }
  },
  emits: ["result"],
  setup(e, { emit: n }) {
    const t = e, { showScanQrPopup: o, closeScanQrPopup: a } = Ve();
    return b(() => o(
      {
        text: t.text
      },
      (i) => n("result", i)
    )), W(
      () => a()
    ), (i, c) => (A(), v("div"));
  }
}), it = {
  install(e) {
    e.component("TgAlert", se), e.component("TgBackButton", ie), e.component("TgConfirm", re), e.component("TgMainButton", ce), e.component("TgPopup", ue), e.component("TgScanQr", Ke);
  }
};
export {
  se as Alert,
  ie as BackButton,
  re as Confirm,
  ce as MainButton,
  ue as Popup,
  Ke as ScanQr,
  it as default,
  u as useWebApp,
  ve as useWebAppBackButton,
  Ge as useWebAppClipboard,
  Xe as useWebAppClosingConfirmation,
  Ye as useWebAppCloudStorage,
  Ze as useWebAppHapticFeedback,
  Pe as useWebAppMainButton,
  et as useWebAppNavigation,
  h as useWebAppPopup,
  Ve as useWebAppQrScanner,
  tt as useWebAppRequests,
  nt as useWebAppSendData,
  ot as useWebAppSettingsButton,
  at as useWebAppTheme,
  st as useWebAppViewport
};
